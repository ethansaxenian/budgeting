// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: budgets.sql

package database

import (
	"context"
)

const createNewBudgetsForMonth = `-- name: CreateNewBudgetsForMonth :many
INSERT INTO budgets (month_id, category, amount, transaction_type)
VALUES
($1, 'food', 0, 'expense'),
($1, 'food', 0, 'income'),
($1, 'gifts', 0, 'expense'),
($1, 'gifts', 0, 'income'),
($1, 'home', 0, 'expense'),
($1, 'home', 0, 'income'),
($1, 'medical', 0, 'expense'),
($1, 'medical', 0, 'income'),
($1, 'transportation', 0, 'expense'),
($1, 'transportation', 0, 'income'),
($1, 'personal', 0, 'expense'),
($1, 'personal', 0, 'income'),
($1, 'savings', 0, 'expense'),
($1, 'savings', 0, 'income'),
($1, 'utilities', 0, 'expense'),
($1, 'utilities', 0, 'income'),
($1, 'travel', 0, 'expense'),
($1, 'travel', 0, 'income'),
($1, 'other', 0, 'expense'),
($1, 'other', 0, 'income'),
($1, 'paycheck', 0, 'expense'),
($1, 'paycheck', 0, 'income'),
($1, 'bonus', 0, 'expense'),
($1, 'bonus', 0, 'income'),
($1, 'interest', 0, 'expense'),
($1, 'interest', 0, 'income'),
($1, 'cashback', 0, 'income'),
($1, 'cashback', 0, 'expense')
RETURNING id, month_id, category, amount, transaction_type, created_at, updated_at
`

func (q *Queries) CreateNewBudgetsForMonth(ctx context.Context, monthID int) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, createNewBudgetsForMonth, monthID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Budget{}
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.MonthID,
			&i.Category,
			&i.Amount,
			&i.TransactionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetItemsByMonthIDAndTransactionType = `-- name: GetBudgetItemsByMonthIDAndTransactionType :many
SELECT budget_id, month_id, category, transaction_type, planned, actual FROM budget_items WHERE month_id = $1 AND transaction_type = $2
`

type GetBudgetItemsByMonthIDAndTransactionTypeParams struct {
	MonthID         int
	TransactionType TransactionType
}

func (q *Queries) GetBudgetItemsByMonthIDAndTransactionType(ctx context.Context, arg GetBudgetItemsByMonthIDAndTransactionTypeParams) ([]BudgetItem, error) {
	rows, err := q.db.QueryContext(ctx, getBudgetItemsByMonthIDAndTransactionType, arg.MonthID, arg.TransactionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BudgetItem{}
	for rows.Next() {
		var i BudgetItem
		if err := rows.Scan(
			&i.BudgetID,
			&i.MonthID,
			&i.Category,
			&i.TransactionType,
			&i.Planned,
			&i.Actual,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchBudget = `-- name: PatchBudget :one
UPDATE budgets SET amount = $1 WHERE id = $2
RETURNING id, month_id, category, amount, transaction_type, created_at, updated_at
`

type PatchBudgetParams struct {
	Amount float64
	ID     int
}

func (q *Queries) PatchBudget(ctx context.Context, arg PatchBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, patchBudget, arg.Amount, arg.ID)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.MonthID,
		&i.Category,
		&i.Amount,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
