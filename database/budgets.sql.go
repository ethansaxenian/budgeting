// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: budgets.sql

package database

import (
	"context"

	"github.com/ethansaxenian/budgeting/types"
)

const createNewBudgetsForMonth = `-- name: CreateNewBudgetsForMonth :many
INSERT INTO budgets (month_id, category, amount, transaction_type)
VALUES
($1, 'food', 0, 'expense'),
($1, 'food', 0, 'income'),
($1, 'gifts', 0, 'expense'),
($1, 'gifts', 0, 'income'),
($1, 'home', 0, 'expense'),
($1, 'home', 0, 'income'),
($1, 'medical', 0, 'expense'),
($1, 'medical', 0, 'income'),
($1, 'transportation', 0, 'expense'),
($1, 'transportation', 0, 'income'),
($1, 'personal', 0, 'expense'),
($1, 'personal', 0, 'income'),
($1, 'savings', 0, 'expense'),
($1, 'savings', 0, 'income'),
($1, 'utilities', 0, 'expense'),
($1, 'utilities', 0, 'income'),
($1, 'travel', 0, 'expense'),
($1, 'travel', 0, 'income'),
($1, 'other', 0, 'expense'),
($1, 'other', 0, 'income'),
($1, 'paycheck', 0, 'expense'),
($1, 'paycheck', 0, 'income'),
($1, 'bonus', 0, 'expense'),
($1, 'bonus', 0, 'income'),
($1, 'interest', 0, 'expense'),
($1, 'interest', 0, 'income'),
($1, 'cashback', 0, 'income'),
($1, 'cashback', 0, 'expense')
RETURNING id, month_id, category, amount, transaction_type, created_at, updated_at
`

func (q *Queries) CreateNewBudgetsForMonth(ctx context.Context, monthID int) ([]Budget, error) {
	rows, err := q.db.QueryContext(ctx, createNewBudgetsForMonth, monthID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Budget
	for rows.Next() {
		var i Budget
		if err := rows.Scan(
			&i.ID,
			&i.MonthID,
			&i.Category,
			&i.Amount,
			&i.TransactionType,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBudgetByID = `-- name: GetBudgetByID :one
SELECT id, month_id, category, amount, transaction_type, created_at, updated_at FROM budgets WHERE id = $1
`

func (q *Queries) GetBudgetByID(ctx context.Context, id int) (Budget, error) {
	row := q.db.QueryRowContext(ctx, getBudgetByID, id)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.MonthID,
		&i.Category,
		&i.Amount,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBudgetsByMonthIDAndType = `-- name: GetBudgetsByMonthIDAndType :many
SELECT id, month_id, category, amount, transaction_type
FROM budgets
WHERE month_id = $1 AND transaction_type = $2
`

type GetBudgetsByMonthIDAndTypeParams struct {
	MonthID         int
	TransactionType types.TransactionType
}

type GetBudgetsByMonthIDAndTypeRow struct {
	ID              int
	MonthID         int
	Category        types.Category
	Amount          float64
	TransactionType types.TransactionType
}

func (q *Queries) GetBudgetsByMonthIDAndType(ctx context.Context, arg GetBudgetsByMonthIDAndTypeParams) ([]GetBudgetsByMonthIDAndTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getBudgetsByMonthIDAndType, arg.MonthID, arg.TransactionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBudgetsByMonthIDAndTypeRow
	for rows.Next() {
		var i GetBudgetsByMonthIDAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.MonthID,
			&i.Category,
			&i.Amount,
			&i.TransactionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchBudget = `-- name: PatchBudget :one
UPDATE budgets SET amount = $1 WHERE id = $2
RETURNING id, month_id, category, amount, transaction_type, created_at, updated_at
`

type PatchBudgetParams struct {
	Amount float64
	ID     int
}

func (q *Queries) PatchBudget(ctx context.Context, arg PatchBudgetParams) (Budget, error) {
	row := q.db.QueryRowContext(ctx, patchBudget, arg.Amount, arg.ID)
	var i Budget
	err := row.Scan(
		&i.ID,
		&i.MonthID,
		&i.Category,
		&i.Amount,
		&i.TransactionType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
